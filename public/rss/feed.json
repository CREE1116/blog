{
    "version": "https://jsonfeed.org/version/1",
    "title": "[크리의 끄적끄적] 크리의 끄적끄적",
    "home_page_url": "https://cree-devblog.net",
    "feed_url": "https://cree-devblog.net/rss/feed.json",
    "description": "간단한 개발을 하는 크리의 블로그 입니다",
    "icon": "https://cree-devblog.net/images/그냥크리.jpeg",
    "author": {
        "name": "Cree",
        "url": "https://cree-devblog.net"
    },
    "items": [
        {
            "id": "2023_03_29_첫글.mdx",
            "content_html": "\r\n---\r\n\r\n# 블로그를 만든 이유\r\n\r\n- 그래도 한명의 컴공과 학생으로써 기술 블로그 하나는 있어야 하지 않나 라는 생각을 했었다.\r\n  그렇게 velog등등 이것저것 맛을 봤는데, 편하고 좋기는 하지만 그래도 내가 코딩을 하는 인간인데 한번쯤 만들어보는것이 좋지 않나 하여 이렇게 기본적인 블로그를 만들었다.\r\n\r\n# 사용한 스텍\r\n\r\n- Next.js\r\n- React.js\r\n- ContantLayer\r\n\r\n앞으로 무언가 만들게 된다면 그 과정을 이곳에 기록할 예정이며, 포스트 뿐만 아니라 기능상으로도 업데이트를 통해 좀더 블로그 구실을 하는 블로그를 만들어 볼까 한다.\r\n",
            "url": "https://cree-devblog.net/blog/2023_03_29_첫글",
            "title": "첫 글",
            "summary": "블로그 제작후 첫 소감",
            "image": "https://cree-devblog.net//images/java-jeans.jpg",
            "date_modified": "2023-03-29T00:00:00.000Z",
            "author": {
                "name": "Cree",
                "url": "https://cree-devblog.net"
            },
            "tags": [
                "블로그",
                "첫글"
            ]
        },
        {
            "id": "2023_03_30_ProgressBar+Comment.mdx",
            "content_html": "\r\n---\r\n\r\n# 개발할 부분 선정 이유\r\n\r\n### ProgressBar\r\n\r\n> 이야 이거 멋있다!\r\n\r\n참고용으로 다른 분들의 블로그를 찾아볼때마다 눈에 들어오던것이었다.\r\n사실 막 그닥 필요한 장치는 아니지만 막 어려워 보이지 않아서 만들어보기로 했다\r\n\r\n### Comment\r\n\r\n> 블로그라면 있어야지!\r\n\r\n기술블로그니까! 있어야지! 라는 마음으로 도입해보기로 했다.\r\n\r\n---\r\n\r\n## ProgressBar\r\n\r\nprogressbar의 작동원리는 이렇다.\r\n\r\n1. 페이지 로드시 지금 스크롤과 뷰포트를 읽어와 퍼센트로 변환한다.\r\n2. 스크롤 리스너를 통해 스크롤이 발생할때마다 읽어온다.\r\n3. 읽어온 스크롤 퍼센트(?)에 따라 ProgressBar의 X를 Translate를 통해 변화시킨다.\r\n\r\n전체 코드는 이렇다.\r\n\r\n```javascript\r\nimport { useEffect, useState } from \"react\";\r\nconst Progressbar = () => {\r\n  const [percentage, setPercentage] = useState(100);\r\n\r\n  const getScrollPercentage = () => {\r\n    const scroll = document.documentElement.scrollTop;\r\n    const scrollHeight = document.documentElement.scrollHeight;\r\n    const clientHeight = document.documentElement.clientHeight;\r\n    const viewport = scrollHeight - clientHeight;\r\n    const percentage = (scroll / viewport) * 100;\r\n    return setPercentage(percentage);\r\n  };\r\n\r\n  useEffect(() => {\r\n    getScrollPercentage();\r\n    window.addEventListener(\"scroll\", getScrollPercentage);\r\n    return () => window.removeEventListener(\"scroll\", getScrollPercentage);\r\n  }, []);\r\n  return (\r\n    <div className=\"fixed top-0 left-0 right-0\">\r\n      <div\r\n        className=\"bg-red-500 h-1\"\r\n        style={{ transform: `translateX(${percentage - 100}%)` }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\nexport default Progressbar;\r\n```\r\n\r\n여기서 `useEffect` 부분을 보면 `getScrollPercentage()`가 한번 호출 되고 난 뒤 윈도우리스너를 등록하는데\r\n이는 글이 너무 짧아서 스크롤이 발생하지 않는 경우 Progressbar가 0%에서 고정되어있는 현상을 해결하기 위해 작성되었다.\r\n\r\n```javascript\r\nconst getScrollPercentage = () => {\r\n  const scroll = document.documentElement.scrollTop;\r\n  const scrollHeight = document.documentElement.scrollHeight;\r\n  const clientHeight = document.documentElement.clientHeight;\r\n  const viewport = scrollHeight - clientHeight;\r\n  const percentage = (scroll / viewport) * 100;\r\n  return setPercentage(percentage);\r\n};\r\n```\r\n\r\n이부분은 스크롤을 %로 구하는 부분이다.\r\n스크롤을 viewport값으로 나눠서 퍼센트로 구하는 코드이다.\r\n\r\n```\r\n<div className=\"fixed top-0 left-0 right-0\">\r\n  <div\r\n    className=\"bg-red-500 h-1\"\r\n    style={{ transform: `translateX(${percentage - 100}%)` }}\r\n  />\r\n</div>\r\n```\r\n\r\ntailwindCss 를 사용했으며\r\n`fixed top-0 left-0 right-0`는 progressbar를 최상단에 고정하는 부분이다.  \r\n`bg-red-500 h-1`는 progressbar를 빨간색으로 하고, 높이를 정하는 부분이다.  \r\n`` style={{transform: `translateX(${(percentage - 100)}%)`}} ``는 퍼센트에 따라서 길이를 변형시키는 코드이다.  \r\n`percentage - 100` 인 이유는 왼쪽부터 오른쪽으로 진행해야 하기 때문이다.\r\n(궁금하면 그냥 `percentage`해봐라 뭔 소리인지 이해할것이다.)\r\n\r\n이렇게 Next.js의 컴포넌트로 구현을 해두었다.\r\n\r\n---\r\n\r\n### Comment\r\n\r\n댓글은 DB를 만들어서 API를 통해 구현해도 되지만 간단한 사이드프로젝트이기때문에 DB구현부터 백앤드 구현은 좀 투머치라고 생각해서 이미 있는 방법들중 Giscus를 이용하기로 했다.\r\n\r\ngiscus를 이용하는 이유는 다음과 같다.\r\n\r\n1. 일단 공식 문서가 한글화되어있는 점에서 접근성이 편하다.\r\n2. 깃허브의 토론을 이용하기때문에 깃허브를 사용하는 사람이라면 접근성도, 보기도 좋다.\r\n3. Next.js용 페키지가 있다...(구현할거 없어서 짱 좋음)\r\n\r\n간단하게 사용하는법을 적어두자면  \r\n[giscus페이지](https://giscus.app/ko)\r\n\r\n    1. 깃헙에서 Public으로 레파지토리를 하나 판다(블로그를 배포한다고 파둔 레파지토리가 Public이라면 그냥 그거 써도 된다.)\r\n    2. 토론 탭을 활성화 시킨다.(세팅 들어가서 General에서 쭉 내리다 보면 있다.)\r\n    3. giscus문서에 가서 필요한것들을 적는다.(문서 링크는 위쪽에 있다.)\r\n    4. 나온 값들을 일단 킵해둔다.\r\n    5. giscus 페키지를 설치한다.\r\n    \t(React나 Next.js라면\r\n    \tyarn add @giscus/react\r\n    \tor\r\n    \tnpm i @giscus/react)\r\n    를 통해 설치할수있다.\r\n    6.잘 쓴다.\r\n\r\n다음은 전체 코드이다.\r\n\r\n```javascript\r\nimport Giscus from \"@giscus/react\";\r\n\r\nconst Comment = () => {\r\n  return (\r\n    <div className=\"border-t-[100px] border-transparent\">\r\n      <Giscus\r\n        id=\"comments\"\r\n        repo=\"내 레파지토리에욧!\"\r\n        repoId=\"내 레파지토리 아이디에욧!\"\r\n        category=\"General\"\r\n        categoryId=\"문서에 기입할거 다 적으면 알아서 나와욧!\"\r\n        mapping=\"pathname\"\r\n        reactionsEnabled=\"1\"\r\n        emitMetadata=\"0\"\r\n        inputPosition=\"top\"\r\n        theme=\"light\"\r\n        lang=\"ko\"\r\n        loading=\"lazy\"\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Comment;\r\n```\r\n\r\n(진짜 뭐 없다...)\r\n\r\n이렇게 구현된 것들은 지금 이 포스트를 보고있는 지금 만나볼수 있다.\r\n\r\n그럼 오늘은 이만.. 자자..\r\n",
            "url": "https://cree-devblog.net/blog/2023_03_30_ProgressBar+Comment",
            "title": "ProgressBar + Comment 구현",
            "summary": "스크롤에 따른 Progress Bar와 giscus 댓글 기능 구현",
            "image": "https://cree-devblog.net/images/그냥크리.jpeg",
            "date_modified": "2023-03-30T00:00:00.000Z",
            "author": {
                "name": "Cree",
                "url": "https://cree-devblog.net"
            },
            "tags": [
                "Next.js",
                "React",
                "TailwindCss",
                "Giscus",
                "progressbar",
                "comment"
            ]
        },
        {
            "id": "2023_04_05_썸네일, 태그,다크모드 구현(1).mdx",
            "content_html": "\r\n---\r\n\r\n생각보다 자주 블로그를 수정하면서도 포스팅하기가 귀찮아져서 미루고 있다가 진행한 순서대로 차근차근 써보려고 한다.\r\n\r\n# 수정된 부분!\r\n\r\n1. 다크모드가 추가되었다.(이 포스트에선 이부분만 다룬다.)\r\n2. 상단 레이아웃이 따라다닌다.\r\n3. blog 페이지에서 각 포스팅별 썸네일과 tag가 표시된다.\r\n\r\n## 다크모드\r\n\r\n    \t> \"다크모드는 개발자의 아주 소중한 친구지\"\r\n\r\n그냥 급하게 지어내서 만들어본 말이다.  \r\n그만큼 오랜시간 화면을 보는 개발자에게 있어서 다크모드는 중요하기에 한번 추가해 봤다.\r\n\r\n일단 우리가 지금 사용하는 tailwind css는 아주 간단하게 다크모드를 지원한다.\r\n\r\n`dark: ` 라는 키워드를 통해 다크모드시 적용될 css를 기입할수있다.\r\n\r\n이런식으로 적용한 부분을 하나 하나 다 쓰자고 하면 너무 많으니 대표적으로 몇개만 가져온다면\r\n\r\n```typescript\r\n\r\n<header\r\nclassName={`fixed top-0 left-0 right-0 bg-white dark:bg-gray-800`}\r\n>\r\n```\r\n\r\n이렇게 원랜 흰색이지만 다크모드에서 어두운 회색으로 바뀌게 할수 있다.\r\n\r\n그외에 너무 자주 쓰이는 것들은 `global.css` 에 적용해 두었는데 기본적인 text가 흰색으로 바뀌거나 배경이 짙은 회색으로 바뀌게 하는 코드다\r\n\r\n```css\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n\r\n@layer base {\r\n  body {\r\n    @apply bg-white text-black dark:bg-gray-800 dark:text-white;\r\n  }\r\n}\r\n```\r\n\r\n근데 이런식으로 하면 tailwind css는 기본적으로 `media`에 따라 다크모드를 조절하게 되어서 기기의 세팅값만을 따라가게 된다.\r\n\r\n분명 심플하고 섹시한 구현방식은 맞지만 내가 원하는건 그것이 아니다.\r\n\r\n뭔가 장난기 넘치고 쓸모없어 보이게 전구를 키면 밝아지고 끄면 어두워지는 그런걸 원한단 말이다.\r\n\r\n이걸 구현할수 있는 방법이 무엇일까 하고 구글링을 열심히 해보았다.\r\n\r\n그 결과 찾아낸것이\r\n\r\n`tailwindcss.config`에서 `darkmode`속성을 `\"class\"` 로 지정해주는 것이었다.\r\n\r\n```typescript\r\nmodule.exports = {\r\n  content: [\r\n    \"./pages/**/*.{js,ts,jsx,tsx}\",\r\n    \"./components/**/*.{js,ts,jsx,tsx}\",\r\n  ],\r\n  darkMode: \"class\",\r\n  theme: {\r\n    extend: {},\r\n  },\r\n  plugins: [require(\"@tailwindcss/typography\")],\r\n};\r\n```\r\n\r\n이렇게 되면 `_app.tsx` (최상위 테그라고 생각하자 그냥)의 classname에서 다크모드를 지정해줄수 있다.\r\n\r\n그런데 이렇게 하면 좀 뭔가 어설퍼진다.\r\n\r\n글의 색만 바뀌고 여전히 배경색은 시스템 테마를 따라가게 된다.\r\n\r\n이유는 막 엄청 잘 알겠는건 아니지만 배경과같은 요소는 classname을 바꾼다고해서 media를 아에 무시하지 않는 모양이었다?..\r\n(이유를 아는 분은 좀 알려주세요 )\r\n\r\n그래서 검색을 또 열심히 한 결과 `next-themes`를 사용하기로 했다.\r\n\r\n> npm install next-themes\r\n> or\r\n> yarn add next-themes\r\n\r\n를 통해 가볍게 설치할수 있다.\r\n\r\n`next-themes`를 사용하면 `useTheme()`라는 훅과 `ThemeProvider`라는 컴포넌트를 사용할수 있다.\r\n\r\n이제 최상위 엘리먼트를 `ThemeProvider`로 감싸고 `attribute` 속성을 `class`로 설정한다.\r\n\r\n```typescript\r\nimport { ThemeProvider } from \"next-themes\";\r\nimport \"../styles/globals.css\";\r\n\r\nimport type { AppProps } from \"next/app\";\r\n\r\nfunction MyApp({ Component, pageProps }: AppProps) {\r\n  return (\r\n    <ThemeProvider attribute=\"class\">\r\n      <Component {...pageProps} />\r\n    </ThemeProvider>\r\n  );\r\n}\r\n\r\nexport default MyApp;\r\n```\r\n\r\n이제 우리 맘대로 태마를 바꿀수 있게 되었다.\r\n\r\n그럼 간단하게 ` useTheme`을 사용해 테마 변경 버튼을 만들어 본다.\r\n\r\n```typescript\r\nimport { useTheme } from \"next-themes\";\r\nimport Image from \"next/image\";\r\n\r\nconst Togglebtn = () => {\r\n  const { theme, setTheme } = useTheme();\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      onClick={() => setTheme(theme === \"dark\" ? \"light\" : \"dark\")}\r\n      // 클릭시 다크모드면 라이트로 바꿈\r\n      className={`mr-3 animate-pulse`}\r\n    >\r\n      {theme === \"light\" ? (\r\n        <Image\r\n          src={`/on.png`}\r\n          alt={\"\"}\r\n          width={30}\r\n          height={30}\r\n          className={`rounded-3xl hover:cursor-pointer`}\r\n        />\r\n      ) : (\r\n        <Image\r\n          src={`/off.png`}\r\n          alt={\"\"}\r\n          width={30}\r\n          height={30}\r\n          className={`rounded-3xl hover:cursor-pointer`}\r\n        />\r\n      )}\r\n    </button>\r\n  );\r\n};\r\n\r\nexport default Togglebtn;\r\n```\r\n\r\n`useTheme`은 약간 테마 전용 `useState`와 비슷하다고 생각하면 된다.\r\n\r\n이렇게 다크모드가 추가되었다.\r\n",
            "url": "https://cree-devblog.net/blog/2023_04_05_썸네일, 태그,다크모드 구현(1)",
            "title": "썸네일, 태그, 다크모드 구현(1)",
            "summary": "tailwindcss를 통한 다크모드와 화면에 고정되어있는 레이아웃, 블로그 페이지에서 볼수있는 썸네일을 구현",
            "image": "https://cree-devblog.net/images/그냥크리.jpeg",
            "date_modified": "2023-04-05T00:00:00.000Z",
            "author": {
                "name": "Cree",
                "url": "https://cree-devblog.net"
            },
            "tags": [
                "tailwindcss",
                "next.js",
                "blog",
                "darkmode",
                "tags"
            ]
        },
        {
            "id": "2023_04_05_썸네일, 태그,다크모드 구현(2).mdx",
            "content_html": "\r\n---\r\n\r\n1탄이 다크모드만으로 좀 길어진것 같아 2편으로 잘라서 나머지를 한번 해보려고 한다.\r\n\r\n# 수정된 부분!\r\n\r\n1. 다크모드가 추가되었다.\r\n2. 상단 레이아웃이 따라다닌다.\r\n3. blog 페이지에서 각 포스팅별 썸네일과 tag가 표시된다.\r\n\r\n나머지 레이아웃과 tag를 이번 포스트에서 알아보자\r\n\r\n## 레이아웃?\r\n\r\n사실 뭐 별거 없다...\r\n\r\n```jsx\r\n<header\r\nclassName={`fixed top-0 left-0 right-0 bg-white dark:bg-gray-800`}\r\n>\r\n\t<div\r\n\tclassName={`w-full flex flex-row justify-between items-center my-1 shadow-md p-3 z-50`\r\n\t>\r\n\t\t<Link href=\"/\">\r\n\t\t\t<a className={\"flex flex-row items-center\"}>\r\n\t\t\t\t<Image\r\n\t\t\t\tsrc={`/java-jeans.jpg`}\r\n\t\t\t\talt=\"로고\"\r\n\t\t\t\twidth={40}\r\n\t\t\t\theight={40}\r\n\t\t\t\tobjectFit={`cover`}\r\n\t\t\t\tclassName={`rounded-full`}\r\n\t\t\t\t/>\r\n\t\t\t\t<span className={`mx-2 font-extralight text-lg`}>\r\n\t\t\t\t\t{metadata.title}\r\n\t\t\t\t</span>\r\n\t\t\t</a>\r\n\t\t</Link>\r\n\t\t<Togglebtn />\r\n\t\t<Nav />\r\n\t</div>\r\n</header>\r\n```\r\n\r\n저기서 `header`부분에 `fixed` 를 이용해서 상단에 절대 좌표로 고정하면 된다...  \r\n개선 하긴 했으니까 넣은건데 굳이 머 티를 낼것인가 싶긴 하다.\r\n\r\n## 썸네일\r\n\r\n어떤 식으로 만들까 고민을 했던 부분이다.\r\n\r\n현제 블로그의 구조는 `./post` 에 마크다운으로 작성된 글을 올리면 `contantlayer`에서 빌드시 자동으로 JSON으로 바꿔주고, 이것을 불러오는 형식으로 작동한다.\r\n\r\n즉 내가 편하려면 이 마크다운에서 썸넬을 결정할수 있어야 한다고 생각을 했다.\r\n\r\n그러기 위해서 `contantlayer.config`를 수정했어야 했는데 수정하는 김에 tags기능도 같이 구현해보기로 했다.\r\n\r\n```Typescript\r\nimport { defineDocumentType, makeSource } from \"contentlayer/source-files\";\r\n\r\nexport const Post = defineDocumentType(() => ({\r\n\tname: \"Post\",\r\n\tcontentType: \"mdx\",\r\n\tfilePathPattern: `**/*.mdx`,\r\n\tfields: {\r\n\t\ttitle: { type: \"string\", required: true },\r\n\t\tdate: { type: \"string\", required: true },\r\n\t\tdescription: { type: \"string\", required: true },\r\n\t\ttags: { type: \"list\", of: { type: \"string\" } },\r\n\t\timage: { type: \"string\" },\r\n\t},\r\n}));\r\n\r\nexport default makeSource({\r\n\tcontentDirPath: \"posts\",\r\n\tdocumentTypes: [Post],\r\n});\r\n```\r\n\r\n`fields`항목에서 tags와 image를 추가했다.\r\n\r\n이렇게 되면 mdx형식으로 포스팅을 작성할때 두 항목을 기입해 자동으로 JSON을 생성하도록 할수있다.\r\n\r\n```\r\n---\r\ntitle: 썸네일, 태그, 다크모드 구현(1)\r\ndate: 2023-04-05\r\ndescription: tailwindcss를 통한 다크모드와 화면에 고정되어있는 레이아웃, 블로그 페이지에서 볼수있는 썸네일을 구현\r\ntags: [tailwindcss, next.js, blog, darkmode, tags]\r\nimage: /java-jeans.jpg\r\n---\r\n```\r\n\r\n(이런 식으로 기입한다.)\r\n\r\n그럼 자동으로 생성된 JSON에는 image항목에 내가 기입한 이미지의 위치가 들어가게 될것이고, 이걸 읽어와서 옆에 이쁘게 놓아주기만 하면 되는것이다.\r\n\r\n다만!.. 이미지를 넣지 않는 경우 그냥 횡 하니 비어있는것이 꼴보기 싫기에 간단하게 제목정도를 적어두는 회색 창을 하나 만들것이다.\r\n\r\n```Typescript\r\n<div className=\"flex-initial w-[30%] relative\">\r\n\t{imagesrc !== undefined ? (\r\n\t\t<Image\r\n\t\tsrc={imagesrc}\r\n\t\talt={title}\r\n\t\tquality={80}\r\n\t\tlayout=\"fill\"\r\n\t\tobjectFit=\"cover\"\r\n\t\tobjectPosition=\"center\"\r\n\t\tclassName={`absolute, rounded-2xl`}\r\n\t\t/>\r\n\t) : (\r\n\t\t<div className=\"absolute bg-gray-500 rounded-2xl w-full h-full text-center py-8 font-bold text-md text-white\">\r\n\t\t\t{title}\r\n\t\t</div>\r\n\t)}\r\n</div>\r\n```\r\n\r\n또한 테그 기능을 구현할 것이니, 리스트 형태의 태그를 출력하는 간단한 span도 하나 만들어 보자\r\n\r\n```Typescript\r\n{tags !== undefined ? tags.map((tag, index) => {\r\n\treturn (\r\n\t\t<span\r\n\t\tkey={index}\r\n\t\tclassName={`text-xs text-gray-400 font-light mt-1`}\r\n\t\t>\r\n\t\t\t#{tag}\r\n\t\t</span>\r\n\t\t);\r\n\t})\r\n: null}\r\n```\r\n\r\n(전체 코드)\r\n\r\n```javascript\r\nimport Link from \"next/link\";\r\nimport Image from \"next/image\";\r\n\r\nconst BlogPost = ({ date, title, des, slug, tags, imagesrc }) => {\r\n  return (\r\n    <Link href={`/blog/${slug}`} passHref>\r\n      <a className=\"w-full my-7 hover:-translate-x-1.5 flex\">\r\n        <div className=\"flex-initial w-[70%]\">\r\n          <div className=\"font-medium text-xs text-gray-400\">\r\n            {date.split(\"T\")[0]}\r\n          </div>\r\n          <div className={`font-extrabold text-2xl mt-2`}>{title}</div>\r\n          <div className={`font-medium text-gray-600 text-xl mt-1`}>{des}</div>\r\n          {tags !== undefined\r\n            ? tags.map((tag, index) => {\r\n                return (\r\n                  <span\r\n                    key={index}\r\n                    className={`text-xs text-gray-400 font-light mt-1`}\r\n                  >\r\n                    #{tag}\r\n                  </span>\r\n                );\r\n              })\r\n            : null}\r\n        </div>\r\n        <div className=\"flex-initial w-[30%] relative\">\r\n          {imagesrc !== undefined ? (\r\n            <Image\r\n              src={imagesrc}\r\n              alt={title}\r\n              quality={80}\r\n              layout=\"fill\"\r\n              objectFit=\"cover\"\r\n              objectPosition=\"center\"\r\n              className={`absolute, rounded-2xl`}\r\n            />\r\n          ) : (\r\n            <div className=\"absolute bg-gray-500 rounded-2xl w-full h-full text-center py-8 font-bold text-md text-white\">\r\n              {title}\r\n            </div>\r\n          )}\r\n        </div>\r\n      </a>\r\n    </Link>\r\n  );\r\n};\r\n\r\nexport default BlogPost;\r\n```\r\n\r\n이렇게 된다.\r\n\r\n관련된 정보는 `blog/index.tsx`에서 받아오게 된다.\r\n\r\n```typescript\r\nconst Blog = ({ posts }: InferGetStaticPropsType<typeof getStaticProps>) => {\r\n  return (\r\n    <Container>\r\n      <div className={`mt-10 flex flex-col`}>\r\n        {posts.map((post) => (\r\n          <BlogPost\r\n            date={post.date}\r\n            title={post.title}\r\n            des={post.description}\r\n            slug={post._raw.flattenedPath}\r\n            key={post._id}\r\n            tags={post.tags}\r\n            imagesrc={post.image}\r\n          />\r\n        ))}\r\n      </div>\r\n    </Container>\r\n  );\r\n};\r\n```\r\n\r\n다음 포스팅에서 돌아오게따\r\n바꾼거 이것저것 있는데 정리하려니 귀찮다.\r\n",
            "url": "https://cree-devblog.net/blog/2023_04_05_썸네일, 태그,다크모드 구현(2)",
            "title": "썸네일, 태그, 다크모드 구현(2)",
            "summary": "tailwindcss를 통한 다크모드와 화면에 고정되어있는 레이아웃, 블로그 페이지에서 볼수있는 썸네일을 구현",
            "image": "https://cree-devblog.net/images/그냥크리.jpeg",
            "date_modified": "2023-04-05T00:00:00.000Z",
            "author": {
                "name": "Cree",
                "url": "https://cree-devblog.net"
            },
            "tags": [
                "tailwindcss",
                "next.js",
                "blog",
                "darkmode",
                "tags"
            ]
        },
        {
            "id": "2023_04_12_SEO관련것들.mdx",
            "content_html": "\r\n---\r\n\r\n개발은 필받으면 한번에 몰아하지만 포스팅은 천천히 쓰는 나란 사람, 결국 포기하고 아무렇게나 하기로 했다.\r\n\r\n오늘은 이 블로그의 seo를 위해 한것들을 알아보고자 한다.\r\n\r\n대략\r\n\r\n1. 메타테그\r\n2. rss\r\n3. sitemap\r\n\r\n순서로 간략하게만 알아보려고 한다.\r\n\r\n## 1. 메타테그\r\n\r\n> `<meta>`\r\n\r\n이 테그는 이 html문서의 메타데이터를 표기하는 테그로 알고있다(?)\r\n\r\n우리가 흔히 `<head>` 테그 안에 들어가는 `<title>` 테그라던가 `<link>` 테그들에서 표현하지 못하는 값들을 표시하게 되는데\r\n\r\n필자는 description 과 keyword를 사용했다.\r\n\r\n사실 좀 더 많이 사용하긴 했지만 이건 OpenGraph지원을 위한것이니 다음 포스팅에서 다뤄보도록 하겠다.\r\n\r\n이 다음은 코드를 보면서 이야기 해보고자 한다.\r\n\r\n```typescript\r\nconst router = useRouter();\r\nconst meta = {\r\n  title: metadata.title,\r\n  description: metadata.description,\r\n  author: metadata.author,\r\n  site_name: metadata.site_name,\r\n  siteUrl: metadata.siteUrl,\r\n  url: router.asPath,\r\n  ...props.customMeta,\r\n};\r\n```\r\n\r\n`<head>`에 들어갈 내용들은 가장 먼저 `json` 의 형태로 담아둔다.\r\n꼭 메타데이터를 만들기 위한것이 아니라 이것저것 사용될 여지가 많기 때문에 쓰는것이다.\r\n\r\n참고로 `metadata`는 data폴더에 있는 단순한 타입스크립트 파일이다.\r\n\r\n```Typescript\r\nconst metadata = {\r\n\ttitle: \"크리의 끄적끄적\",\r\n\tdescription: \"간단한 개발을 하는 크리의 블로그 입니다\",\r\n\tsite_name: \"[크리의 끄적끄적]\",\r\n\tauthor: \"Cree\",\r\n\tsiteUrl: \"https://cree-devblog.net\",\r\n\temail: 이거 왜적어놨더라,\r\n};\r\n\r\nexport default metadata;\r\n```\r\n\r\n그리고 내 블로그의 `<head>`테그가 있는 컴포넌트에서 `<meta>`테그를 사용한 부분이다.\r\n\r\n```Typescript\r\n<Head>\r\n\t<meta name=\"description\" content={meta.description} />\r\n\t{meta.keyword !== undefined ? (\r\n\t\t<meta name=\"keyword\" content={meta.keyword} />\r\n\t) : null}\r\n<Head/>\r\n```\r\n\r\n상당히 보잘것 없다... 머 그래도 SEO에겐 좀 중요한 부분이다.\r\n\r\n## 2.RSS\r\n\r\n> RSS(Really Simple Syndication, Rich Site Summary)란 **블로그처럼 컨텐츠 업데이트가 자주 일어나는 웹사이트에서, 업데이트된 정보를 쉽게 구독자들에게 제공하기 위해 XML을 기초로 만들어진 데이터 형식**입니다.\r\n\r\n구글에 그냥 검색해봤더니 기상청에서 이렇게 설명해 주더라\r\n\r\n![img](/postImages/2023_04_12_1st.png)\r\n\r\n(따란...)\r\n\r\n즉 그냥 내 블로그 이렇게 생겼어요~~ 하고 말해주는 거라고 생각하면 된다.\r\n\r\n이와 유사하게 `ATOM` 도 있는데 이 역시 비슷하다.\r\n\r\n현제 나의 블로그의 rss는 [https://cree-devblog.net/rss/rss.xml](https://cree-devblog.net/rss/rss.xml)로 들어가면 볼수있다.\r\n\r\n이 rss를 매번 내가 작성할수는 없기 때문에 feed라는 플러그인? 페키지를 사용했는데\r\n\r\n손쉽게 rss와 atom은 물론 Json Feed도 만들어주는 친구이다... 만\r\n\r\nJson피드는 아직 지원하는곳이 많이 없는듯 하다\r\n\r\n나는 이 블로그를 vercel을 통한 정적페이지로 배포중이기때문에 빌드시에 이 rss를 생성하며\r\n\r\n```json\r\n\"build\": \"next build\",\r\n\"postbuild\": \"next-sitemap && npm run rss\",\r\n\"rss\": \"ts-node --project tsconfig.node.json ./scripts/generate-rss.ts\"\r\n```\r\n\r\n그렇기에 이러한 빌드 커멘드를 사용한다.\r\n\r\n그리고 저기서 실행하는 `generate-rss.ts`를 살펴보자면\r\n\r\n```typescript\r\nimport { Feed } from \"feed\";\r\nimport { writeFileSync } from \"fs\";\r\n\r\nimport PostJson from \"../.contentlayer/generated/Post/_index.json\";\r\nimport metadata from \"../data/metadata\";\r\n\r\nconst master = {\r\n  name: metadata.author,\r\n  link: metadata.siteUrl,\r\n  email: metadata.email,\r\n};\r\n\r\nconst feed = new Feed({\r\n  title:\r\n    metadata.title.length > 0\r\n      ? `[크리의 끄적끄적] ${metadata.title}`\r\n      : metadata.site_name,\r\n\r\n  description: metadata.description,\r\n  id: metadata.siteUrl,\r\n  link: metadata.siteUrl,\r\n  language: \"ko\",\r\n  image: `${metadata.siteUrl}/images/그냥크리.jpg`,\r\n  copyright: `All rights reserved since 2023-03-29, ${master.name}`,\r\n  generator: \"generate-rss\",\r\n  feedLinks: {\r\n    json: `${metadata.siteUrl}/rss/feed.json`,\r\n    atom: `${metadata.siteUrl}/rss/rss-atom.xml`,\r\n  },\r\n  author: master,\r\n});\r\n\r\nPostJson.forEach((post) => {\r\n  feed.addItem({\r\n    title: post.title,\r\n    id: post._id,\r\n    link: `${metadata.siteUrl}/blog/${post._raw.flattenedPath}`,\r\n    description: post.description,\r\n    content: post.body.raw,\r\n    author: [master],\r\n    image:\r\n      post.image !== undefined\r\n        ? `${metadata.siteUrl}/${post.image}`\r\n        : `${metadata.siteUrl}/images/그냥크리.jpeg`,\r\n    contributor: [master],\r\n    date: new Date(post.date),\r\n    category: post.tags.map((tag) => ({ name: tag, term: \"Technologies\" })),\r\n  });\r\n});\r\n// Output: RSS 2.0\r\nwriteFileSync(\"public/rss/rss.xml\", feed.rss2(), \"utf-8\");\r\n// Output: Atom 1.0\r\nwriteFileSync(\"public/rss/rss-atom.xml\", feed.atom1(), \"utf-8\");\r\n// Output: JSON Feed 1.0\r\nwriteFileSync(\"public/rss/feed.json\", feed.json1(), \"utf-8\");\r\n```\r\n\r\nFeed에 기본 정보를 넣고, 각 포스트의 정보를 읽어와 추가 한 다음 `wirteFileSync`로 작성해주기만 하면 된다.\r\n\r\n## sitemap\r\n\r\n어찌보면 이게 rss보다 먼저 나오는게 좋을것 같은데.. 머\r\n\r\n아까 본 빌드커멘드에서 next-sitemap이라고 적힌걸 봤을것이다.\r\n\r\n이게 그거다\r\n\r\n이친구도 대부분의 플러그인들이 그러하듯 `config`에 따라 작동하며\r\n\r\n자동으로 사이트맵과 `robot.txt`를 만들어주는 역할을 한다.\r\n\r\n### 사이트맵\r\n\r\n    내 사이트 지도다 여기 링크에 이거있고 언제 왔어요 라고 적어두는것이며, 이걸 검색포털의 크롤러가 읽는다.\r\n    그냥 둬도 읽기야 하겠지만 이렇게 지도를 제공해주면 보다 빨리 읽을수 있다.\r\n\r\n### robot.txt\r\n\r\n    킹갓 크롤러님께 이 사이트를 어떻게 해주세요 라고 적어두는 문서이다.\r\n    어떤 크롤러에게 허용할까, 어디까지만 읽게 할까 등등을 기입할수있따.\r\n\r\n다음은 `next-sitemap`의 설정 파일이다\r\n\r\n```Typescript\r\nmodule.exports = {\r\n\tsiteUrl: \"https://cree-devblog.net\",\r\n\tgenerateRobotsTxt: true,\r\n\tchangefreq: \"hourly\",\r\n\tsitemapSize: 7000,\r\n\tpriority: 1,\r\n\trobotsTxtOptions: {\r\n// 정책 설정\r\n\t\tpolicies: [\r\n\t\t\t{\r\n\t\t\t\tuserAgent: \"*\", // 모든 agent 허용\r\n\t\t\t\tallow: \"/\", // 모든 페이지 주소 크롤링 허용\r\n\t\t\t\tdisallow: [\r\n\t\t\t\t\t\"/exclude\", // exclude로 시작하는 페이지 주소 크롤링 금지\r\n\t\t\t\t],\r\n\t\t\t},\r\n// 추가 정책이 필요할 경우 배열 요소로 추가 작성\r\n\t\t],\r\n\t}, // robots.txt 옵션 설정\r\n};\r\n```\r\n\r\n이것으로 포스팅을 마친다.. 다들 고생..\r\n",
            "url": "https://cree-devblog.net/blog/2023_04_12_SEO관련것들",
            "title": "SEO에 관련된 것들을 구현해보자",
            "summary": "seo에 관련된 사이트맵, 메타테그, rss등을 적용하고 서치콘솔과 서치 어드바이저에 등록해보자",
            "image": "https://cree-devblog.net/images/그냥크리.jpeg",
            "date_modified": "2023-04-12T00:00:00.000Z",
            "author": {
                "name": "Cree",
                "url": "https://cree-devblog.net"
            },
            "tags": [
                "SEO",
                "next.js",
                "blog",
                "sitemap",
                "rss",
                "jsonfeed",
                "search console"
            ]
        }
    ]
}